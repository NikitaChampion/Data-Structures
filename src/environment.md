# Как настроить окружение на своем компьютере

## Введение

С недавнего времени на сервере используется новая схема тестирования решений, а точнее, отлавливается большее число ошибок за счет использования других ключей компиляции. Цель этой заметки &mdash; помочь вам получить такой же эффект на своей системе.

Помимо этого, описанные здесь рекомендации позволят вам организовать более качественное тестирование кода.

На сервере компилируется 2 варианта вашего решения, а именно:

```bash
g++-8 solution.cpp -std=c++17 -O2 -Wall -Werror -Wsign-compare -o fast_solution
g++-8 solution.cpp -fuse-ld=gold -fsanitize=address,undefined -fno-sanitize-recover=all -std=c++17 -O2 -Wall -Werror -Wsign-compare -o debug_solution
```

Здесь стоит отметить следующее:
1. `-Wall` и `-Werror`. Первый флаг заставляет компилятор выдавать дополнительные предупреждения, второй &mdash; трактовать любое предупреждение как ошибку компиляции. Таким образом, ваш код не должен давать ни одного предупреждения.
2. `-O2` включает оптимизации кода.
3. `-std=c++17` нужен для использования стандарта `C++17`. Если вы не особо обращаете внимание на используемый стандарт, то можете продолжать это делать и писать, как раньше. Остальные могут использовать все фишки нового стандарта.

Во втором случае решение компилируется с включенными *санитайзерами*. Любое обращение за пределы массива, знаковое переполнение целочисленных типов и любые подобные проявления некорректной работы с памятью и undefined behavior будут вызывать ошибку времени выполнения и приводить к вердикту Runtime Error на сервере, а не ситуации, когда ваша программа иногда работает, а иногда нет.

Обратите внимание, что `-fsanitize=address` также включает детектор утечек памяти. Поэтому, помимо контроля над тем, куда обращается ваша программа, на сервере также производится проверка, что в вашей программе нет утечек памяти (сделали `new` и не сделали `delete`). В подавляющем большинстве случаев вам вообще в будущем не нужно оперировать с динамической памятью вручную (например, для создания массивов используйте стандартные контейнеры вроде `std::vector`, которые правильно обращаются с памятью).

Поскольку санитайзеры вносят заметный оверхед в решение (значительно увеличивается потребляемая память и в несколько раз может возрасти время исполнения), то они используются только для запуска на маленьких тестах (обычно не более первых десяти в задаче), чтобы правильные решения не могли получить вердикты ML или TL.

Компилируется и запускается всё на `Intel(R) Xeon(R) CPU E5-2660 @ 2.20GHz, 20480KB cache, virtualizаtion on 1 core, 4GB RAM` с Linux-ом.

## Примеры кода
Давайте рассмотрим на примерах, как работает компилятор с указанным выше набором флагов. В этом разделе приведены комментарии по поведению `gcc` и `clang` в linux с включенными санитайзерами. Про другие ОС см. секции ниже.

Здесь происходит знаковое переполнение при вычислении `BAD_MAX_INT`, что порождает соответствующее предупреждение. В десятой строке происходит сравнение `int` и `size_t`, что также порождает предупреждение. **Никогда** не игнорируйте это предупреждение: при таком сравнении `int` приводится к беззнаковому типу, таким образом, неравенство `-1 > size_t` всегда выполнено. Этот код не компилируется с флагом `-Werror`.
```cpp
#include <iostream>
#include <vector>

const int BAD_MAX_INT = (1 << 31) - 1;

int main() {
    size_t n;
    std::cin >> n;
    std::vector<int> data(n);
    for (int i = 0; i < data.size(); ++i) {
        std::cin >> data[i];
    }
    return 0;
}
```

В этом примере происходит очевидный выход за пределы массива. Если заменить динамический массив на `std::vector`, произойдет то же самое. И `gcc`, и `clang` успешно отловят данную ошибку с включенными санитайзерами.
```cpp
#include <iostream>
#include <vector>

int main() {
    size_t n;
    std::cin >> n;
    int *data = new int[n];
    for (size_t i = 0; i < n; ++i) {
        std::cin >> data[i];
    }
    std::cout << data[n] << "\n";
    delete[] data;
    return 0;
}
```

В этом примере есть утечка памяти (нет `delete[]`)
```cpp
#include <iostream>
#include <vector>

int main() {
    size_t n;
    std::cin >> n;
    int *data = new int[n];
    for (size_t i = 0; i < n; ++i) {
        std::cin >> data[i];
    }
    return 0;
}
```

Здесь возникает `undefined behavior` при переполнении (введем `2000000000 2000000000`), который отловят и `clang` и `gcc` с включенным флагом `-fsanitize=undefined`.
```cpp
#include <iostream>

int main() {
    int a, b;
    std::cin >> a >> b;
    std::cout << a + b << "\n";
    return 0;
}
```

## Настройка на своей системе

Мы рекомендуем использовать среду CLion для разработки. Всем студентам ВШЭ предоставляется бесплатная лицензия. Вы можете работать из любой ОС, однако добиться поведения, описанного выше, можно только на Linux и Mac OS. Опыт показывает, что **отлавливать ошибки c обращениями за пределы массива, знаковым переполнением целочисленных типов и любыми подобными проявлениями некорректной работы с памятью и undefined behavior с использованием Windows достаточно мучительно**, поэтому лучше заранее озаботиться установкой Linux. Самый удобный вариант &mdash; развернуть VirtualBox. Если же у вас Windows 10, то еще одним вариантом будет установка [WSL](https://docs.microsoft.com/en-us/windows/wsl/install-win10) и [его интеграция с CLion](https://www.jetbrains.com/help/clion/how-to-use-wsl-development-environment-in-clion.html).

Ниже приведена инструкция для CLion.

Создайте новый проект, зайдите в File -> Settings -> Build, Execution, Deployment -> CMake. Изначально там будет только один профиль Debug. Когда вы нажмете + добавится
профиль Release, который пригодится в дальнейшем. Добавьте еще один профиль, назовите его ASAN. В CMake Options запишите
```bash
-DCMAKE_BUILD_TYPE=ASAN
``` 

Отредактируйте ваш `CMakeLists.txt`. Он будет выглядеть примерно так:
```cmake
cmake_minimum_required(VERSION 3.12)
project(my_project)

set(CMAKE_CXX_STANDARD 17)

set(CMAKE_CXX_FLAGS_ASAN "-g -fsanitize=address,undefined -fno-sanitize-recover=all"
        CACHE STRING "Compiler flags in asan build"
        FORCE)

add_executable(my_project main.cpp)
```

Теперь вы легко можете переключаться между разными видами сборок: Debug для пошагового дебага, Release для тестирования производительности, ASAN для запуска
с санитайзерами.

<details><summary>Windows</summary>

На Windows без использования WSL санитайзеры не работают. Вы точно так же можете использовать CLion, но поддержки asan там не будет (если только вы не настроили интеграцию с WSL, см. ссылки выше).
</details>

<details><summary>Mac OS</summary>

По сравнению с Linux, на маке необходимо произвести ряд дополнительных действий, чтобы получить такое же поведение. Для начала обязательно установите `gcc` из `brew`, никогда не используйте системный `gcc`. Выполните

```bash
brew install gcc
```

Чтобы проверить, что gcc установился правильно, выполните (11 нужно заменить на версию gсс, установленную brew):
```bash
g++-11 --version  # выведет полную версию g++
which g++-11  # выведет полный путь к компилятору, например /usr/local/bin/g++-11
```

Далее необходимо прописать путь к новому компилятору в настройках CLion. Для этого зайдите в CLion -> Preferences -> Build, Execution, Deployment -> Toolchains и в C++ compiler пропишите полный путь к компилятору.

Далее, **обратите внимание**, что по умолчанию под маком asan не включает проверку на утечки памяти. Чтобы этого избежать, зайдите в CLion -> Preferences -> Build, Execution, Deployment -> Dynamic Analysis Tools -> Sanitizers и в конце строчки AddressSanitizer допишите строчку

```bash
detect_leaks=1
```

Иногда на маках при компиляции с asanом может выпадать большое количество ошибок, не связанных с вашим кодом. В этом случае попробуйте добавить флаг `-fsanitize-undefined-trap-on-error` для asan-сборки (переменная `CMAKE_CXX_FLAGS_ASAN` в `CMakeLists.txt`).
</details>

## Проверка на соответствие стайлгайду и форматирование кода

Инструкция ниже для Linux и Mac OS.

Вам понадобятся утилиты clang-format и clang-tidy, они обычно есть в стандартных репозиториях (`apt-get install` или `brew install`). Для clang-format вы можете взять конфиг [отсюда](https://raw.githubusercontent.com/NikitaChampion/Data-Structures/main/codestyle/.clang-format), а для clang-tidy
[отсюда](https://raw.githubusercontent.com/NikitaChampion/Data-Structures/main/codestyle/.clang-tidy).

Положите эти файлы в директорию с кодом или в домашнюю директорию.

Для форматирования кода выполните
```bash
clang-format -i main.cpp
```

Вы также можете настроить автоматическое форматирование кода с помощью этой утилиты в [CLion](https://www.jetbrains.com/help/clion/clangformat-as-alternative-formatter.html).

Для дополнительных проверок на именование переменных, функций и прочего выполните
```bash
clang-tidy main.cpp -- -std=c++17
```

По умолчанию, когда лежит .clang-tidy в директории с кодом или в домашней директории, CLion подсвечивает неправильное именование переменных, функций и прочего как ошибки.
